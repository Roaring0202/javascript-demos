<!doctype html>
<html ng-app="Demo">
<head>
	<meta charset="utf-8" />

	<title>
		Creating An Isolate-Scope Directive With Multiple Transclusion Points In AngularJS
	</title>

	<link rel="stylesheet" type="text/css" href="./demo.css"></link>
</head>
<body ng-controller="AppController as vm">

	<h1>
		Creating An Isolate-Scope Directive With Multiple Transclusion Points In AngularJS
	</h1>

	<!-- 
		This Layout component creates an isolate scope, but transcludes the 
		contents of each one of the embedded "panels" so that the content of 
		each panel can access the outer scope of the context while the structure
		of the component can remain encapsulated.
	-->
	<layout size="vm.size">
		<layout-panel role="header">

			Layout Header

		</layout-panel>
		<layout-panel role="body">

			<!-- 
				These values will all be bound to the outer scope, NOT to the
				ISOLATE scope. 
			-->

			<p>
				Layout Body - Size: {{ vm.size }}
			</p>

			<p>
				<a ng-click="vm.toggleSize()">Toggle Size</a>
			</p>

			<p>
				Sanity Check: {{ vm.message }}
			</p>

		</layout-panel>
		<layout-panel role="footer">

			Layout Footer

		</layout-panel>
	</layout>


	<!-- Load scripts. -->
	<script type="text/javascript" src="../../vendor/jquery/jquery-2.1.0.min.js"></script>
	<script type="text/javascript" src="../../vendor/angularjs/angular-1.4.5.js"></script>
	<script type="text/javascript">

		// Create an application module for our demo.
		var app = angular.module( "Demo", [] );


		// --------------------------------------------------------------------------- //
		// --------------------------------------------------------------------------- //


		// I control the root of the application.
		angular.module( "Demo" ).controller(
			"AppController",
			function AppController( $scope ) {

				var vm = this;

				// I hold the desired size of the layout. This is passed into the 
				// layout component as a isolate-bound attribute.
				vm.size = "small";

				// I hold a sanity-check value to make sure the isolate layout scope
				// and the main scope are not colliding.
				vm.message = "Hello world!";
				
				// Expose public methods.
				vm.toggleSize = toggleSize;


				// ---
				// PUBLIC METHODS.
				// ---


				// I toggle the currently-desired size of the layout component.
				function toggleSize() {

					vm.size = ( vm.size === "small" )
						? "large"
						: "small"
					;

				}

			}
		);


		// --------------------------------------------------------------------------- //
		// --------------------------------------------------------------------------- //


		// I provide a layout with thee panels - header, footer, and body.
		// --
		// NOTE: This component directive is broken up into two different priorities.
		// We need to do this because we need to access the element content before the
		// "template" is applied, which is not currently possible in a single directive
		// (that I know of). As such, the first pass inspects the element and gathers up
		// the linking functions; then, the second pass pulls in the template and 
		// performs the transclusion.
		angular.module( "Demo" ).directive(
			"layout",
			function layoutDirective( $compile ) {

				// Return the directive configuration.
				// --
				// NOTE: We are creating an isolate-scope along with a Controller.
				return({
					controller: LayoutController,
					controllerAs: "vm",
					compile: compile,
					priority: -1,
					restrict: "E",
					scope: {
						layoutSize: "=size"
					},
					terminal: true
				});


				// I compile the 
				function compile( tElement ) {

					var linkFunctions = {};

					tElement.children( "layout-panel" ).each(
						function iterator( i, node ) {

							var panel = angular.element( node );
							var role = panel.attr( "role" );

							if ( role ) {

								linkFunctions[ role ] = $compile( panel.contents() );

							}

						}
					);

					return( link );


					function link( scope, element, attribute, controller ) {

						// Once the controller is instantiated, 
						// I hold the link functions for the transcludable content. This will
					// be consumed in the second-pass of this directive.
						controller.linkFunctions = linkFunctions;

						$compile( element, null, -1 )( scope );

					}

				}


				// I control the Layout component directive.
				function LayoutController( $scope ) {

					var vm = this;

					// Create a ReactJS-inspired props object for bound attributes.
					var props = $scope.props = $scope;

					// As a sanity check, let's define a value that we know will also
					// be defined on the parent scope. This way, we can see if any
					// scope collision takes place.
					vm.message = "From isolate scope.";

				}

			}
		);

		
		angular.module( "Demo" ).directive(
			"layout",
			function layoutDirective() {

				// Return the directive configuration.
				return({
					link: link,
					require: "layout",
					restrict: "E",
					priority: -2,
					template:
					`
						<div class="layout-inner" ng-class="{ large: ( props.layoutSize == 'large' ) }">
							<div class="layout-header">
								<!-- Transcuded. -->
							</div>
							<div class="layout-body">
								<!-- Transcuded. -->
							</div>
							<div class="layout-footer">
								<!-- Transcuded. -->
							</div>
						</div>
					`
				});


				// I transclude the content and bind JavaScript events to the local 
				// view-model.
				function link( scope, element, attributes, controller ) {

					var transcludeScope = scope.$parent;
					var inner = element.children( "div.layout-inner" );
					var headerPanel = inner.children( "div.layout-header" );
					var bodyPanel = inner.children( "div.layout-body" );
					var footerPanel = inner.children( "div.layout-footer" );

					controller.linkFunctions.header(
						transcludeScope,
						function attachClone( clone, scope ) {

							headerPanel.append( clone );

						}
					);

					controller.linkFunctions.body(
						transcludeScope,
						function attachClone( clone, scope ) {

							bodyPanel.append( clone );

						}
					);

					controller.linkFunctions.footer(
						transcludeScope,
						function attachClone( clone, scope ) {

							footerPanel.append( clone );

						}
					);

				}

			}
		);

	</script>

</body>
</html>






















<!doctype html>
<html ng-app="Demo">
<head>
	<meta charset="utf-8" />

	<title>
		Creating A Component Directive With Multiple Transclusion Points In AngularJS
	</title>

	<link rel="stylesheet" type="text/css" href="./demo.css"></link>
</head>
<body ng-controller="AppController as vm">

	<h1>
		Creating A Component Directive With Multiple Transclusion Points In AngularJS
	</h1>
	
	<!-- 
		This Layout component creates an isolate scope, but transcludes the 
		contents of each one of the embedded "panels" so that the content of 
		each panel can access the outer scope of the context while the structure
		of the component can remain encapsulated.
	-->
	<layout size="vm.size">
		<layout-panel role="header">

			Layout Header

		</layout-panel>
		<layout-panel role="body">

			<p>
				Layout Body - Size: {{ vm.size }}
			</p>

			<p>
				<a ng-click="vm.toggleSize()">Toggle Size</a>
			</p>

		</layout-panel>
		<layout-panel role="footer">

			Layout Footer

		</layout-panel>
	</layout>


	<!-- Load scripts. -->
	<script type="text/javascript" src="../../vendor/jquery/jquery-2.1.0.min.js"></script>
	<script type="text/javascript" src="../../vendor/angularjs/angular-1.4.5.min.js"></script>
	<script type="text/javascript">

		// Create an application module for our demo.
		var app = angular.module( "Demo", [] );


		// --------------------------------------------------------------------------- //
		// --------------------------------------------------------------------------- //


		// I control the root of the application.
		angular.module( "Demo" ).controller(
			"AppController",
			function AppController( $scope ) {

				var vm = this;

				// I hold the desired size of the layout.
				vm.size = "small";
				
				// Expose public methods.
				vm.toggleSize = toggleSize;


				// ---
				// PUBLIC METHODS.
				// ---


				// I toggle the curerntly-desired size of the layout component.
				function toggleSize() {

					vm.size = ( vm.size === "small" )
						? "large"
						: "small"
					;

				}

			}
		);


		// --------------------------------------------------------------------------- //
		// --------------------------------------------------------------------------- //


		// I provide a layout with thee panels - header, footer, and body.
		angular.module( "Demo" ).directive(
			"layout",
			function layoutDirective( $compile ) {

				// Return the directive configuration.
				return({
					compile: compile,
					restrict: "E",

					// We are telling the component to use an isolate scope.
					scope: {
						layoutSize: "=size"
					},

					template: `<p>test{{layoutSize}}</p>`,

					// Since we need to completely mess with the internals of the 
					// component markup, we'll make this a terminal component, which
					// means that the content will not be compiled until we explicitly
					// compile it.
					terminal: false
				});


				// I update and compile the content of the directive.
				function compile( tElement, tAttributes ) {
console.log( tElement );
return;
					// Right now, the content is all wrapped inside panels that are 
					// acting as delimiters for the panels roles. Locate each panel 
					// so that we can process its content.
					var headerPanel = tElement.children( "layout-panel[ role = 'header' ]" );
					var bodyPanel = tElement.children( "layout-panel[ role = 'body' ]" );
					var footerPanel = tElement.children( "layout-panel[ role = 'footer' ]" );

					// Since this component is a "terminal" component, we have to 
					// manually compile the content. Create linking functions for the 
					// content of each panel.
					// --
					// CAUTION: These will be linked to the $parent scope.
					var headerLink = $compile( ensureElements( headerPanel.contents() ) );
					var bodyLink = $compile( ensureElements( bodyPanel.contents() ) );
					var footerLink = $compile( ensureElements( footerPanel.contents() ) );

					// Since this component is a "terminal" component, we need to 
					// explicitly compile and link the isolate-scope "shadow DOM" that
					// we're going to use as our "template".
					// --
					// CAUTION: This will be linked to the isolate scope.
					var shadowDomLink = $compile(
						`
							<div class="layout-inner" ng-class="{ large: ( layoutSize == 'large' ) }">
								<div class="layout-header">
									<!-- Transcuded. -->
								</div>
								<div class="layout-body">
									<!-- Transcuded. -->
								</div>
								<div class="layout-footer">
									<!-- Transcuded. -->
								</div>
							</div>
						`
					);

					return( link );


					// I transclude the content and bind JavaScript events to the local 
					// view-model.
					function link( scope, element, attributes ) {

						// Since our component is linking in an isolate-scope, we have
						// to get a reference to the parent scope so that we can properly
						// transclude the panel content.
						var panelScope = scope.$parent;

						// Transclude and append our "shadow DOM". This is the component's
						// internal structure for the panel layout.
						shadowDomLink(
							scope,
							function applyClone( clone ) {

								element
									.empty()
									.append( clone )
								;

							}
						);

						// Transclude the header panel.
						headerLink(
							panelScope,
							function applyClone( clone ) {

								element.find( "div.layout-header" )
									.empty()
									.append( clone )
								;

							}
						);

						// Transclude the body panel.
						bodyLink(
							panelScope,
							function applyClone( clone ) {

								element.find( "div.layout-body" )
									.empty()
									.append( clone )
								;

							}
						);

						// Transclude the footer panel.
						footerLink(
							panelScope,
							function applyClone( clone ) {

								element.find( "div.layout-footer" )
									.empty()
									.append( clone )
								;

							}
						);

					}

				}


				// When we transclude content, only elements are appended. As such, we
				// have to ensure that the non-empty text nodes are wrapped in Span tags
				// so that AngularJS will merge them in properly.
				function ensureElements( collection ) {

					var ensured = collection.map(
						function operator( index, node ) {

							if ( isNonEmptyTextNode( node ) ) {

								return( angular.element( "<span></span>" ).append( node )[ 0 ] );

							}

							return( node );

						}
					);

					return( ensured );

				}


				// I determine if the given node is a text node that consists of more 
				// than just white-space.
				function isNonEmptyTextNode( node ) {

					return( 
						( node.nodeType === 3 ) && 
						( node.nodeValue.search( /\S+/ ) !== -1 )
					);

				}

			}
		);

	</script>

</body>
</html>


// Load the core node modules.
var AngularCompilerPlugin = require( "@ngtools/webpack" ).AngularCompilerPlugin;
var CleanWebpackPlugin = require( "clean-webpack-plugin" );
var HtmlWebpackPlugin = require( "html-webpack-plugin" );
var path = require( "path" );
var webpack = require( "webpack" );

// We are exporting a Function instead of a configuration object so that we can
// dynamically define the configuration object based on the execution context.
module.exports = ( env, argv ) => {

	// Locally, we want robust source-maps. However, in production, we want something
	// that can help with debugging without giving away all the information. This
	// production setting will give us proper file-names and line-numbers, but without
	// actually providing any code content.
	var devtool = ( argv.mode === "development" )
		? "cheap-module-eval-source-map"
		: "nosources-source-map"
	;

	return({
		// I define the base-bundles that will be generated.
		// --
		// NOTE: Additional bundles may be created during optimization and code-splitting.
		entry: {
			polyfill: "./app/main.polyfill.ts",
			main: "./app/main.ts"
		},
		// I define the bundle file-name scheme.
		output: {
			filename: "[name].[chunkhash].js",
			path: path.join( __dirname, "build" )
		},
		devtool: devtool,
		resolve: {
			extensions: [ ".ts", ".js" ]
		},
		module: {
			rules: [
				// I provide a TypeScript compiler that performs Ahead of Time (AoT)
				// compiling for the Angular application and TypeScript code.
				{
					test: /(\.ngfactory\.js|\.ngstyle\.js|\.ts)$/,
					loader: "@ngtools/webpack"
				},
				// When the @ngtools webpack loader runs, it will replace the @Component()
				// "templateUrl" and "styleUrls" with inline "require()" calls. As such, we
				// need the raw-loader so that require() will know how to load .htm and .css
				// file as plain-text.
				{ 
					test: /\.(htm|css)$/, 
					loader: "raw-loader"
				},
				// If our components link to .less files instead of .css files, then the
				// less-loader will parse the LESS CSS file on-the-fly during the require() 
				// call that is generated by the @ngtools webpack loader.
				{
					test: /\.less$/,
					loaders: [
						"raw-loader",
						"less-loader"
					]
				}
			]
		},
		plugins: [
			// I clean the build directory before each build.
			new CleanWebpackPlugin([
				path.join( __dirname, "build/*.js" ),
				path.join( __dirname, "build/*.js.map" )
			]),

			// I work with the @ngtools webpack loader to configure the Angular compiler.
			new AngularCompilerPlugin({
				tsConfigPath: path.join( __dirname, "tsconfig.json" ),
				mainPath: path.join( __dirname, "app/main" ),
				entryModule: path.join( __dirname, "app/app.module#AppModule" ),
				// Webpack will generate source-maps independent of this setting. But,
				// this setting uses the original source code as the source-map, rather
				// than the generated / compiled code.
				sourceMap: true
			}),

			// I generate the main "index" file and inject Script tags for the files emitted
			// by the compilation process.
			new HtmlWebpackPlugin({
				// Notice that we are saving the index UP ONE DIRECTORY, so that it is output
				// in the root of the demo.
				filename: "../index.htm",
				template: "./app/main.htm"
			})
		],
		optimization: {
			splitChunks: {
				// Apply optimization to all chunks, even initial ones.
				chunks: "all"
			}
		}
	});

};

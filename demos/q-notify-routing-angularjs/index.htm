<!doctype html>
<html ng-app="Demo">
<head>
	<meta charset="utf-8" />

	<title>
		...... In AngularJS
	</title>

	<!-- <link rel="stylesheet" type="text/css" href="demo.css"></link> -->
</head>
<body ng-controller="AppController">

	<h1>
		...... In AngularJS
	</h1>

	<p>
		<span ng-repeat="friend in friends">
			[ <a ng-href="#/friends/{{ friend.id }}">{{ friend.name }}</a> ]
		</span>	
	</p>

	<div ng-switch="subview">

		<div 
			ng-switch-when="detail" 
			ng-controller="DetailController"
			ng-switch="isLoading">

			Detail.

			<div ng-switch-when="true">

				<em>Loading....</em>

			</div>

			<div ng-switch-when="false">

				{{ friend.name }}

			</div>

		</div>

	</div>



	<!-- Load scripts. -->
	<script type="text/javascript" src="../../vendor/angularjs/angular-1.3.13.min.js"></script>
	<script type="text/javascript" src="../../vendor/angularjs/angular-route-1.3.13.min.js"></script>
	<script type="text/javascript" src="../../vendor/lodash/lodash-3.5.0.min.js"></script>
	<script type="text/javascript">

		// Create an application module for our demo.
		var app = angular.module( "Demo", [ "ngRoute" ] );


		// -------------------------------------------------- //
		// -------------------------------------------------- //


		app.config(
			function configureRoutes( $routeProvider ) {

				$routeProvider
					.when(
						"/friends",
						{
							action: new RouteAction( "friends.list" )
						}
					)
					.when(
						"/friends/:id",
						{
							redirectTo: "/friends/:id/bio",
							action: new RouteAction()
						}
					)
					.when(
						"/friends/:id/bio",
						{
							action: new RouteAction( "friends.detail.bio" )
						}
					)
					.when(
						"/friends/:id/likes",
						{
							action: new RouteAction( "friends.detail.likes" )
						}
					)
					.otherwise({
					 	redirectTo: "/friends",
					 	action: new RouteAction( "" )
					})
				;


				function RouteAction( path ) {

					var path = ( actionPath || "" );
					var parts = path.split( /\./g );

					// Return the public API.
					return({
						at: at,
						isOutside: isOutside,
						startsWith: startsWith						
					});

					
					// ---
					// PUBLIC METHODS.
					// ---


					function at( index ) {

						return( parts[ index ] || "" );

					}


					function isOutside( prefix ) {

						return( ! startsWith( prefix ) );

					}


					function startWith( prefix ) {

						if ( ! prefix ) {

							return( true );

						}

						return( path.indexOf( prefix ) === 0 );

					}

				}

			}
		);


		// -------------------------------------------------- //
		// -------------------------------------------------- //


		// I control the root of the application.
		app.controller(
			"AppController",
			function( $scope, friendService, $route, _ ) {

				$scope.subview = null;

				$scope.friends = [];

				friendService.getList().then(
					function handleResolve( data ) {

						$scope.friends = data;

					}
				);

				$scope.$on( 
					"$routeChangeSuccess",
					function handleRouteChange( event ) {

						if ( $route.current.action.isOutside( "friends" ) ) {

							return;

						}

						$scope.subview = $route.current.action.at( 1 );

					}
				);

			}
		);


		// -------------------------------------------------- //
		// -------------------------------------------------- //


		app.controller(
			"DetailController",
			function( $scope, friendService, $route, $routeParams, _ ) {

				$scope.friendID = ( $routeParams.id * 1 );

				$scope.isLoading = false;

				$scope.subview = null;

				$scope.friend = null;

				$scope.$on( "$routeChangeSuccess", handleRouteChangeEvent );
					
				loadRemoteData();


				// ---
				// PUBLIC METHODS.
				// ---


				function handleRouteChangeEvent( event, newRoute ) {

					if ( ! newRoute.action.startsWith( "friends.detail." ) ) {

						return;

					}

					$scope.subview = newRoute.action.at( 2 );

					var newFriendID = ( $routeParams.id * 1 );

					if ( $scope.friendID !== newFriendID ) {

						$scope.friendID = newFriendID;

						loadRemoteData();

					}

				}


				// ---
				// PRIVATE METHODS.
				// ---


				function loadRemoteData() {

					var requestingFriendID = $scope.friendID;

					$scope.isLoading = true;

					friendService
						.getDetail( $scope.friendID )
						.then( handleDataLoad, angular.noop, handleDataLoad )
					;


					function handleDataLoad( data ) {

						if ( requestingFriendID !== $scope.friendID ) {
							
							return;

						}

						$scope.isLoading = false;

						$scope.friend = data;

					}

				}

			}
		);


		// -------------------------------------------------- //
		// -------------------------------------------------- //


		app.config(
			function simulateHttpLatency( $httpProvider ) {

				$httpProvider.interceptors.push( slowDownRequest );


				function slowDownRequest( $q, $timeout ) {

					return({
						request: function( config ) {

							var latency = $q.defer();

							$timeout(
								function() {

									latency.resolve( config );

									config = latency = null;

								},
								750,
								false // No need trigger a digest.
							);

							return( latency.promise );

						}
					});

				}

			}
		);


		// -------------------------------------------------- //
		// -------------------------------------------------- //

		app.service(
			"friendService",
			function( $q, $http, _ ) {

				var cache = {
					bio: {},
					detail: {},
					likes: {},
					list: {}
				};

				// Return the public API.
				return({
					getBio: getBio,
					getDetail: getDetail,
					getLikes: getLikes,
					getList: getList
				});


				// ---
				// PUBLIC METHODS.
				// ---


				function getBio( id ) {

					var deferred = $q.defer();

					if ( cache.bio[ id ] ) {

						deferred.promise.then( null, null, angular.noop );

						deferred.notify( angular.copy( cache.bio[ id ] ) );

					}

					getData().then(
						function( data ) {

							var friend = _.find( data, { id: id } );

							if ( ! friend ) {

								return( deferred.reject( new Error( "NotFound" ) ) );

							}

							deferred.resolve( 
								angular.copy( cache.bio[ id ] = friend.description )
							);

						},
						deferred.reject
					);

					return( deferred.promise );

				}


				function getDetail( id ) {

					var deferred = $q.defer();


					if ( cache.detail[ id ] ) {

						deferred.promise.then( null, null, angular.noop );

						deferred.notify( angular.copy( cache.detail[ id ] ) );

					}

					getData().then(
						function( data ) {

							var friend = _.find( data, { id: id } );

							if ( ! friend ) {

								return( deferred.reject( new Error( "NotFound" ) ) );

							}

							var data = _.pick( friend, [ "id", "name", "birthday" ] );

							deferred.resolve( 
								angular.copy( cache.detail[ id ] = data )
							);

						},
						deferred.reject
					);

					return( deferred.promise );

				}


				function getLikes( id ) {

					var deferred = $q.defer();

					if ( cache.likes[ id ] ) {

						deferred.promise.then( null, null, angular.noop );

						deferred.notify( angular.copy( cache.likes[ id ] ) );

					}

					getData().then(
						function( data ) {

							var friend = _.find( data, { id: id } );

							if ( ! friend ) {

								return( deferred.reject( new Error( "NotFound" ) ) );

							}

							deferred.resolve( 
								angular.copy( cache.likes[ id ] = friend.likes ) 
							);

						},
						deferred.reject
					);

					return( deferred.promise );

				}


				function getList() {

					var deferred = $q.defer();

					if ( cache.list.data ) {

						deferred.promise.then( null, null, angular.noop );

						deferred.notify( angular.copy( cache.list.data ) );

					}

					getData().then(
						function( data ) {

							var list = _.map( 
								data, 
								function( friend ) {

									return( _.pick( friend, [ "id", "name" ] ) );

								}
							);

							deferred.resolve( 
								angular.copy( cache.list.data = list )
							);

						},
						deferred.reject
					);

					return( deferred.promise );

				}



				// ---
				// PRIVATE METHODS.
				// ---


				function getData() {

					var deferred = $q.defer();

					$http({
						method: "get",
						url: "./friends.json"
					})
					.then(
						function handleResolve( response ) {

							deferred.resolve( response.data );

						},
						function handleReject( response ) {

							deferred.reject( new Error( "NetworkError" ) );

						}
					);

					return( deferred.promise );

				}

			}
		);




		app.factory(
			"_",
			function( $window ) {

				var lodash = $window._;

				delete( $window._ );

				return( lodash );

			}
		);

	</script>

</body>
</html>






















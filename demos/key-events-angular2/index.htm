<!doctype html>
<html>
<head>
	<meta charset="utf-8" />

	<title>
		.... In Angular 2 Beta 14
	</title>

	<link rel="stylesheet" type="text/css" href="./demo.css"></link>
</head>
<body>

	<h1>
		.... In Angular 2 Beta 14
	</h1>

	<my-app>
		Loading...
	</my-app>

	<!-- Load demo scripts. -->
	<script type="text/javascript" src="../../vendor/angularjs-2-beta/14/es6-shim.min.js"></script>
	<script type="text/javascript" src="../../vendor/angularjs-2-beta/14/Rx.umd.min.js"></script>
	<script type="text/javascript" src="../../vendor/angularjs-2-beta/14/angular2-polyfills.min.js"></script>
	<script type="text/javascript" src="../../vendor/angularjs-2-beta/14/angular2-all.umd.js"></script>
	<!-- AlmondJS - minimal implementation of RequireJS. -->
	<script type="text/javascript" src="../../vendor/angularjs-2-beta/14/almond.js"></script>
	<script type="text/javascript">

		// Defer bootstrapping until all of the components have been declared.
		requirejs( 
			[ /* Using require() for better readability. */ ],
			function run() {

				ng.platform.browser.bootstrap( 
					require( "App" ),
					[
						ng.core.provide(
							ng.platform.common_dom.EVENT_MANAGER_PLUGINS,
							{
								useClass: require( "KeyEventPlugin" ),
								multi: true
							}
						)
					]
				);

			}
		);


		// --------------------------------------------------------------------------- //
		// --------------------------------------------------------------------------- //


		// I provide the root application component.
		define(
			"App",
			function registerApp() {

				// Configure the App component definition.
				ng.core
					.Component({
						selector: "my-app",
						directives: [ require( "SubChild" ) ],
						template:
						`	
							This is the root component! Woot.

							<sub-child [foo.bar]="4" (key.cmd+enter)="doSomething( $event )"></sub-child>
						`
					})
					.Class({
						constructor: AppController
					})
				;

				return( AppController );


				// I control the App component.
				function AppController() {

					var vm = this;

					vm.doSomething = doSomething;


					function doSomething( e ) {

						console.log ( "EVENt:", e );

					}


				}

			}
		);


		// --------------------------------------------------------------------------- //
		// --------------------------------------------------------------------------- //


		define(
			"SubChild",
			function registerSubChild() {

				// Configure the SubChild component definition.
				ng.core
					.Component({
						selector: "sub-child",
						inputs: [ "foo.bar" ],
						outputs: [ "key.cmd" ],
						template:
						`
							This is the sub-child! Woot.
						`
					})
					.Class({
						constructor: SubChildController
					})
				;

				return( SubChildController );


				// I control the SubChild component.
				function SubChildController() {

					var vm = this;
					vm.key = {
						cmd: new ng.core.EventEmitter()
					};

					vm.test = new ng.core.EventEmitter();

					vm.foo = {};
					
					setTimeout(function(){
						vm.key.cmd.next( "sub-path" );
						vm.test.next( "test" );

						console.log( vm.foo.bar );
					},500);



				}

			}
		);




		define(
			"KeyEventPlugin",
			function registerKeyEventPlugin() {

				return( KeyEventPlugin );


				// I bind and unbind custom "outside" DOM events.
				function KeyEventPlugin() {

					var vm = this;

					// Expose the public methods.
					// --
					// CAUTION: Generally, I would return a new object with the exposed
					// API. However, in this case, I am simply exposing the public methods
					// so as to remove ambiguity when referencing the "zone", which would
					// not be present on the method call this-binding otherwise (since it
					// injected by the Angular 2 framework via "this.manager").
					vm.addEventListener = addEventListener;
					vm.addGlobalEventListener = addGlobalEventListener;
					vm.supports = supports;


					// ---
					// PUBLIC METHODS.
					// ---


					// I add the given event handler to the given element and return the 
					// event de-registration method.
					function addEventListener( element, eventName, handler ) {

						// NOTE: The "manager" is injected by the Angular framework (via
						// the Event Manager that aggregates the event plugins).
						var zone = vm.manager.getZone();

						// Each "outside" event is captured by an "inside" event at the 
						// document level. Translate the element-local event type to the
						// document-local event type.
						var documentEvent = documentEventMap[ eventName ];

						// Zone.js patches event-target code. As such, when we attach the
						// the document-level event handler, we want to do so outside of
						// the change-detection zone so that our checkEventTarget() 
						// doesn't trigger more change-detection than it has to. Once we
						// know that we have to parle the document-level event into an
						// element-local event, we'll re-enter the Angular zone.
						zone.runOutsideAngular( addDocumentEventListener );

						return( removeDocumentEventListener );


						// I attach the document-local event listener which will determine
						// the origin of the bubbled-up events.
						function addDocumentEventListener() {

							document.addEventListener( documentEvent, checkEventTarget, true );

						}

						// I detach the document-local event listener, tearing down the
						// "outside" event binding.
						function removeDocumentEventListener() {

							document.removeEventListener( documentEvent, checkEventTarget, true );

						}

						// I check to see if the given event originated from within the 
						// host element. If it did, the event is ignored. If it did NOT,
						// then the "outside" event binding is invoked with the given event.
						function checkEventTarget( event ) {

							var current = event.target;

							do {

								if ( current === element ) {

									return;

								}

							} while ( current.parentNode && ( current = current.parentNode ) );

							// If we made it this far, we didn't bubble past the host 
							// element. As such, we know that the event was initiated
							// from outside the host element. It is therefore an 
							// "outside" event and needs to be translated into a host-
							// local event that integrates with change-detection.
							triggerDOMEventInZone( event );

						}

						// I invoke the host event handler with the given event.
						function triggerDOMEventInZone( event ) {

							// Now that we know that the document-local event has to be
							// translated into an element-local host binding event, we 
							// need to re-enter the Angular 2 change-detection zone so
							// that view-model changes made within the event handler will
							// trigger a new round of change-detection.
							zone.run(
								function runInZone() {

									handler( event );

								}
							);

						};
					
					} // END: addEventListener().


					// I register the event on the global target and return the event
					// de-registration method.
					function addGlobalEventListener( target, eventName, handler ) {

						// For the purposes of an "outside" event, it will never be 
						// possible to actually click / mouse outside of the document
						// or the window object. As such, simply ignore these global 
						// context, providing a no-op binding.
						if ( ( target === "document" ) || ( target === "window" ) ) {

							return( noop );

						}

						// If the target was not "document" or "window", it must be body
						// (the only other "global" host binding). While not very likely,
						// it is possible to click outside of the body tag (by clicking 
						// on the HTML tag). As such, let's add the event listener to the
						// body tag directly.
						return( addEventListener( document.body, eventName, handler ) );

					}


					// I check to see if the given event is supported by the plugin.
					function supports( eventName ) {
console.log( "Supports", eventName );
						// If the event can be mapped to a native event on the document,
						// then we can support the event.
						return( false );

					}


					// ---
					// PRIVATE METHODS.
					// ---


					// I perform a no-operation instruction.
					function noop() {

						// Nothing to see here, folks.

					}

				}

			}
		);


	</script>

</body>
</html>